---
title: Python
subtitle: ACTL3143 & ACTL5111 Deep Learning for Actuaries
author: Dr Patrick Laub
format:
  revealjs:
    theme: [serif, custom.scss]
    controls: true
    controls-tutorial: true
    logo: unsw-logo.svg
    footer: "Slides: [Dr Patrick Laub](https://pat-laub.github.io) (@PatrickLaub)."
    title-slide-attributes:
      data-background-image: unsw-yellow-shape.png
      data-background-size: contain !important
    transition: none
    slide-number: c/t
    strip-comments: true
    preview-links: false
    margin: 0.12
    width: 1000
    chalkboard:
      boardmarker-width: 6
      grid: false
      background:
        - "rgba(255,255,255,0.0)"
        - "https://github.com/rajgoel/reveal.js-plugins/raw/master/chalkboard/img/blackboard.png"
    include-before: <div class="line right"></div>
    include-after: <script>registerRevealCallbacks();</script>
highlight-style: breeze
jupyter: python3
execute:
  keep-ipynb: true
  echo: true
---

# Data Science & Python {background-image="unsw-yellow-shape.png"}

## About Python

::: columns
::: {.column width="40%"}
![Free book [Automate the Boring Stuff with Python](https://automatetheboringstuff.com/)](automate-the-boring-stuff-with-python.jpeg)
:::

::: {.column width="60%"}
It is _general purpose_ language

Python powers:

- Instagram
- Spotify
- Netflix
- Uber
- Reddit...

Python is on Mars.

:::
:::

::: footer
Sources: [Blog post](https://learn.onemonth.com/10-famous-websites-built-using-python/) and [Github](https://docs.github.com/en/account-and-profile/setting-up-and-managing-your-github-profile/customizing-your-profile/personalizing-your-profile#list-of-qualifying-repositories-for-mars-2020-helicopter-contributor-badge).
:::


## Stack Overflow [2021 Dev. Survey](https://insights.stackoverflow.com/survey/2021)

::: columns
::: {.column width="55%"}

- Python is [3rd most popular language](https://insights.stackoverflow.com/survey/2021#section-most-popular-technologies-programming-scripting-and-markup-languages)
- Python is the [most wanted language](https://insights.stackoverflow.com/survey/2021#section-most-loved-dreaded-and-wanted-programming-scripting-and-markup-languages)
- In 'Other frameworks and libraries', they note that ["several data science libraries for Python make strong showings"](https://insights.stackoverflow.com/survey/2021#section-most-popular-technologies-other-frameworks-and-libraries
).

:::
::: {.column width="38%"}

![Popular languages.](so-popular-languages-all.png)

:::
:::

## Github's [2021 State of the Octoverse](https://octoverse.github.com/#top-languages-over-the-years)

![Top languages over the years](github-programming-languages.svg)


::: footer
Source: Kaggle (2021), [State of Machine Learning and Data Science](https://www.kaggle.com/kaggle-survey-2021).
:::

```{python}
#| echo: false
#| eval: false
from IPython.display import display, HTML

html = '<div class="r-stack">'

html += f'<img src="kaggle/kaggle-0.png" width="1000px">'

for i in range(1, 18):
    if i in [1, 2, 6, 13, 14, 15, 16]:
        continue
    html += f'<img src="kaggle/kaggle-{i}.png" class="fragment" width="1000px">'

html += "</div>"

display(HTML(html))
``` 

## Python and machine learning


> ...[T]he entire machine learning and data science industry has been dominated by these two approaches: **deep learning** and **gradient boosted trees**...
> Users of gradient boosted trees tend to use Scikit-learn, XGBoost, or LightGBM. Meanwhile, most practitioners of deep learning use Keras, often in combination with its parent framework TensorFlow.
The common point of these tools is **they're all Python libraries**: Python is by far the most widely used language for machine learning and data science.

::: footer
Source: Fran√ßois Chollet (2021), _Deep Learning with Python, Second Edition_, Section 1.2.7.
:::

## Python for data science

::: columns
::: {.column width="50%"}
In R you can run:
```r
pchisq(3, 10)
```
:::
::: {.column width="50%"}
In Python it is
```python
from scipy import stats
stats.chi2(10).cdf(3)
```
:::
:::

![In Leganto](python-data-analysis.jpeg)

## Google Colaboratory

![An example notebook in Google Colaboratory.](google-colab.png)

[http://colab.research.google.com](http://colab.research.google.com)

# Python Data Types {background-image="unsw-yellow-shape.png"}

## Variables and basic types

<br>

::: columns
::: {.column width="50%"}
```{python}
1+2
```

```{python}
x = 1
x+2.0
```

```{python}
type(2.0)
```

```{python}
type(1), type(x)
```

:::
::: {.column width="50%"}

```{python}
doesMathWork = 1 + 1 == 2
print(doesMathWork)
type(doesMathWork)
```

```{python}
contradiction = (1 != 1)
contradiction
```

:::
:::

## Shorthand assignments

If we want to add 2 to a variable `x`:

::: columns
::: {.column width="50%"}
```{python}
x = 1
x = x + 2
x
```
:::

::: {.column width="50%"}
```{python}
x = 1
x += 2
x
```
:::
:::

Same for:

- `x -= 2` : take 2 from the current value of `x` ,
- `x *= 2` : double the current value of `x`,
- `x /= 2` : halve the current value of `x`.

<!-- And for `x **= 2`, `x //= 2`, `x %= 2`. -->

## Strings

```{python}
name = "Patrick"
surname = 'Laub'
```

```{python}
coffee = "This is Patrick's coffee"
quote = 'And then he said "I need a coffee!"'
```

```{python}
name + surname
```

```{python}
greeting = f"Hello {name} {surname}"
greeting
```

```{python}
"Patrick" in greeting
```

## `and` & `or`

```{python}
name = "Patrick"
surname = "Laub"
name.istitle() and surname.istitle()
```

```{python}
fullName = "Dr Patrick Laub"
fullName.startswith("Dr ") or fullName.endswith(" PhD")
```

::: {.callout-important}
The dot is used denote methods, it can't be used inside a variable name.
```{python}
#| error: true
i.am.an.unfortunate.R.users = True
```
:::

## `help` to get more details

```{python}
help(name.istitle)
```

## f-strings

```{python}
print(f"Five squared is {5*5} and five cubed is {5**3}")
print("Five squared is {5*5} and five cubed is {5**3}")
```

::: {.callout-aside}
Use f-strings and avoid the older alternatives:
```{python}
print(f"Hello {name} {surname}")
print("Hello " + name + " " + surname)
print("Hello {} {}".format(name, surname))
print("Hello %s %s" % (name, surname))
```
:::

## Converting types

```{python}
digit = 3
digit
```

```{python}
type(digit)
```

```{python}
num = float(digit)
num
```

```{python}
type(num)
```

```{python}
numStr = str(num)
numStr
```

## Quiz

What is the output of:

```{python}
#| eval: false
x = 1
y = 1.0
print(f"{x == y} and {type(x) == type(y)}")
```

::: fragment
```{python}
#| echo: false
x = 1
y = 1.0
print(f"{x == y} and {type(x) == type(y)}")
```
:::

::: fragment
What would you add before line 3 to get "True and True"?
:::

::: fragment
```{python}
x = 1
y = 1.0
x = float(x) # or y = int(y)
print(f"{x == y} and {type(x) == type(y)}")
```
:::

# Collections {background-image="unsw-yellow-shape.png"}

## Lists

```{python}
desires = ["Coffee", "Cake", "Sleep"]
desires
```

```{python}
len(desires)
```

<!-- ## Indexing lists -->

```{python}
desires[0]
```

```{python}
desires[-1]
```

```{python}
desires[2] = "Nap"
desires
```

## Slicing lists

```{python}
print([0,1,2])
desires
```

```{python}
desires[0:2]
```

```{python}
desires[0:1]
```

```{python}
desires[:2]
```

## A common indexing  error

```{python}
#| error: true
desires[1.0]
```

```{python}
#| error: true
desires[:len(desires)/2]
```

```{python}
len(desires)/2, len(desires)//2
```

```{python}
desires[:len(desires)//2]
```

## Editing lists

```{python}
desires = ["Coffee", "Cake", "Sleep"]
desires.append("Gadget")
desires
```

```{python}
desires.pop()
```

```{python}
desires
```

```{python}
desires.sort()
desires
```

```{python}
#| error: true
desires[3] = "Croissant" # From a question in the ACTL5111 lecture
```

## `None`

```{python}
desires = ["Coffee", "Cake", "Sleep", "Gadget"]
sortedList = desires.sort()
sortedList
```

```{python}
type(sortedList)
```

```{python}
sortedList is None
```

```{python}
bool(sortedList)
```

```{python}
desires = ["Coffee", "Cake", "Sleep", "Gadget"]
sortedList = sorted(desires)
print(desires)
sortedList
```

## Tuples ('immutable' lists)

```{python}
weather = ("Sunny", "Cloudy", "Rainy")
print(type(weather))
print(len(weather))
weather[-1]
```

```{python}
#| error: true
weather.append("Snowy")
```

```{python}
#| error: true
weather[2] = "Snowy"
```

## Dictionaries

```{python}
phoneBook = {"Patrick": "+61412 456 789",
             "Coffee shop": "(02) 1234 4321"}
phoneBook["Patrick"]
```

```{python}
phoneBook["Coffee shop"] = "+61400 000 000"
phoneBook
```

```{python}
phoneBook.keys()
```

```{python}
phoneBook.values()
```

```{python}
factorial = {0:1, 1:1, 2:2, 3:6, 4:24, 5:120, 6:720, 7:5040}
factorial[4]
```

## Quiz

```{python}
#| eval: false
animals = ["dog", "cat", "bird"]
animals.append("teddy bear")
animals.pop()
animals.pop()
animals.append("koala")
animals.append("kangaroo")
print(f"{len(animals)} and {len(animals[-2])}")
```

::: fragment
```{python}
#| echo: false
animals = ["dog", "cat", "bird"]
animals.append("teddy bear")
animals.pop()
animals.pop()
animals.append("koala")
animals.append("kangaroo")
print(f"{len(animals)} and {len(animals[-2])}")
```
:::

# Control Flow {background-image="unsw-yellow-shape.png"}

## `if` and `else`

```{python}
age = 50
```

```{python}
if age >= 30:
    print("Gosh you're old")
```

```{python}
if age >= 30:
    print("Gosh you're old")
else:
    print("You're still young")
```

## The weird part about Python...

```{python}
#| error: true
if age >= 30:
    print("Gosh you're old")
else:
print("You're still young")
```

::: {.callout-warning}
Watch out for mixing tabs and spaces!
:::

## An example of aging

```{python}
age = 16

if age < 18:
    fridayEveningSchedule = "School things"
if age < 30:
    fridayEveningSchedule = "Party ü•≥üçæ"
if age >= 30:
    fridayEveningSchedule = "Work"
```

::: fragment
```{python}
print(fridayEveningSchedule)
```
:::

## Using `elif` {auto-animate=true}

```{python}
age = 16

if age < 18:
    fridayEveningSchedule = "School things"
elif age < 30:
    fridayEveningSchedule = "Party ü•≥üçæ"
else:
    fridayEveningSchedule = "Work"

print(fridayEveningSchedule)
```

## `for` Loops

```{python}
desires = ["coffee", "cake", "sleep"]
for desire in desires:
    print(f"Patrick really wants a {desire}.")
```

<!-- ## Ranges -->

::: columns
::: {.column width="50%"}
```{python}
for i in range(3):
    print(i)
```

```{python}
for i in range(3, 6):
    print(i)
```

:::
::: {.column width="50%"}

```{python}
range(5)
```

```{python}
type(range(5))
```

```{python}
list(range(5))
```

:::
:::

## Advanced `for` loops

```{python}
for i, desire in enumerate(desires):
    print(f"Patrick wants a {desire}, it is priority #{i+1}.")
```

```{python}
desires = ["coffee", "cake", "nap"]
times = ["in the morning", "at lunch", "during a boring lecture"]

for desire, time in zip(desires, times):
    print(f"Patrick enjoys a {desire} {time}.")
```


## While Loops

```{python}
#| echo: false
import numpy.random as rnd
rnd.seed(1234)
simulate_pareto = lambda: rnd.pareto(1)
```

Say that we want to simulate $(X \,\mid\, X \ge 100)$ where $X \sim \mathrm{Pareto}(1)$.
Assuming we have `simulate_pareto`,
a function to generate $\mathrm{Pareto}(1)$ variables:
```{python}
samples = []
while len(samples) < 5:
    x = simulate_pareto()
    if x >= 100:
        samples.append(x)

samples
```

## Breaking out of a loop

```{python}
#| eval: false
while True:
    userInput = input(">> What would you like to do? ")

    if userInput == "order cake":
        print("Here's your cake! üéÇ")

    elif userInput == "order coffee":
        print("Here's your coffee! ‚òïÔ∏è")

    elif userInput == "quit":
        break
```

```{python}
#| echo: false
inputs = ["order cake", "order coffee", "order cake", "quit"]

for userInput in inputs:
    print(f">> What would you like to do? {userInput}")
    if userInput == "order cake":
        print("Here's your cake! üéÇ")

    elif userInput == "order coffee":
        print("Here's your coffee! ‚òïÔ∏è")

    elif userInput == "quit":
        break
```

## Quiz

What does this print out?

```{python}
#| eval: false
if 1/3 + 1/3 + 1/3 == 1:
    if 2**3 == 6:
        print("Math really works!")
    else:
        print("Math sometimes works..")
else:
    print("Math doesn't work")
```

::: fragment
```{python}
#| echo: false
if 1/3 + 1/3 + 1/3 == 1:
    if 2**3 == 6:
        print("Math really works!")
    else:
        print("Math sometimes works..")
else:
    print("Math doesn't work")
```
:::


<!-- ## Quiz -->

What does this print out?

```{python}
#| eval: false
count = 0
for i in range(1, 10):
    count += i
    if i > 3:
        break
print(count)
```

::: fragment
```{python}
#| echo: false
count = 0
for i in range(1, 10):
    count += i
    if i > 3:
        break
print(count)
```
:::

## Debugging the quiz code

```{python}
count = 0
for i in range(1, 10):
    count += i
    print(f"After i={i} count={count}")
    if i > 3:
        break
```

# Python Functions {background-image="unsw-yellow-shape.png"}

## Making a function

```{python}
def addOne(x):
    return x + 1

addOne(10)
```

```{python}
def greet_a_student(name):
    print(f"Hi {name}, welcome to the AI class!")

greet_a_student("Josephine")
```

```{python}
greet_a_student("Joseph")
```

::: {.callout-aside}
Here, `name` is a _parameter_ and the value supplied is an _argument_.
:::

## Default arguments

```{python}
#| echo: false
import numpy.random as rnd
rnd.seed(1234)
simulate_standard_normal = rnd.normal
```

Assuming we have `simulate_standard_normal`,
a function to generate $\mathrm{Normal}(0, 1)$ variables:
```{python}
def simulate_normal(mean=0, std=1):
    return mean + std * simulate_standard_normal()
```

```{python}
simulate_normal() # same as 'simulate_normal(0, 1)'
```

```{python}
simulate_normal(1_000) # same as 'simulate_normal(1_000, 1)'
```

::: {.callout-note}
We'll cover random numbers next week (using `numpy`).
:::

## Use explicit parameter name

```{python}
simulate_normal(mean=1_000)  # same as 'simulate_normal(1_000, 1)'
```

```{python}
simulate_normal(std=1_000)  # same as 'simulate_normal(0, 1_000)'
```

```{python}
simulate_normal(10, std=0.001)  # same as 'simulate_normal(10, 0.001)'
```

```{python}
#| error: true
simulate_normal(std=10, 1_000)
```

## Why would we need that?

E.g. to fit a Keras model, we use the `.fit` method:

```{python}
#| eval: false
model.fit(x=None, y=None, batch_size=None, epochs=1, verbose='auto',
        callbacks=None, validation_split=0.0, validation_data=None,
        shuffle=True, class_weight=None, sample_weight=None,
        initial_epoch=0, steps_per_epoch=None, validation_steps=None,
        validation_batch_size=None, validation_freq=1,
        max_queue_size=10, workers=1, use_multiprocessing=False)
```

Say we want all the defaults except changing `use_multiprocessing=True`:

```{python}
#| eval: false
model.fit(None, None, None, 1, 'auto', None, 0.0, None, True, None,
        None, 0, None, None, None, 1, 10, 1, True)
```

but it is _much nicer_ to just have:
```{python}
#| eval: false
model.fit(use_multiprocessing=True)
```

## Quiz

What does the following print out?

```{python}
#| eval: false
def get_half_of_list(numbers, first=True):
    if first:
        return numbers[:len(numbers)//2]
    else:
        return numbers[len(numbers)//2:]

numbers = [1, 2, 3, 4, 5, 6]
firstHalf = get_half_of_list(numbers, False)
secondHalf = get_half_of_list(firstHalf)
print(secondHalf)
```

::: fragment
```{python}
#| echo: false
def get_half_of_list(numbers, first=True):
    if first:
        return numbers[:len(numbers)//2]
    else:
        return numbers[len(numbers)//2:]

numbers = [1, 2, 3, 4, 5, 6]
firstHalf = get_half_of_list(numbers, False)
secondHalf = get_half_of_list(firstHalf)
print(secondHalf)
```
:::

::: fragment
```{python}
print(f"'numbers' gets broken into {numbers[:len(numbers)//2]} and {numbers[len(numbers)//2:]}")
print(f"'firstHalf' gets broken into {firstHalf[:len(firstHalf)//2]} and {firstHalf[len(firstHalf)//2:]}")
```
:::

## Multiple return values
    
```{python}
def limits(numbers):
    return min(numbers), max(numbers)

limits([1, 2, 3, 4, 5])
```

```{python}
type(limits([1, 2, 3, 4, 5]))
```

```{python}
minNum, maxNum = limits([1, 2, 3, 4, 5])
print(f"The numbers are between {minNum} and {maxNum}.")
```

```{python}
_, maxNum = limits([1, 2, 3, 4, 5])
print(f"The maximum is {maxNum}.")
```

```{python}
print(f"The maximum is {limits([1, 2, 3, 4, 5])[1]}.")
```

## Tuple unpacking

```{python}
lims = limits([1, 2, 3, 4, 5])
smallestNum = lims[0]
largestNum = lims[1]
print(f"The numbers are between {smallestNum} and {largestNum}.")
```

```{python}
smallestNum, largestNum = limits([1, 2, 3, 4, 5])
print(f"The numbers are between {smallestNum} and {largestNum}.")
```

This doesn't just work for functions with multiple return values:

```{python}
RESOLUTION = (1920, 1080)
WIDTH, HEIGHT = RESOLUTION
print(f"The resolution is {WIDTH} wide and {HEIGHT} tall.")
```

## Short-circuiting

```{python}
def is_positive(x):
  print("Called is_positive")
  return x > 0

def is_negative(x):
  print("Called is_negative")
  return x < 0

x = 10
```

::: columns
::: column
```{python}
xIsPositive = is_positive(x)
xIsPositive
```

:::
::: column
```{python}
xIsNegative = is_negative(x)
xIsNegative
```
:::
:::

```{python}
xNotZero = is_positive(x) or is_negative(x)
xNotZero
```

{{< include _importing-packages.qmd >}}

{{< include _python-classes.qmd >}}

{{< include _python-lambdas.qmd >}}

{{< include _object-oriented-programming.qmd >}}

# {data-visibility="uncounted"}

<h2>Glossary</h2>

::: columns
::: column

- default arguments
- dictionaries
- f-strings
- function definitions
- Google Colaboratory
- `help`
- list

:::
::: column

- `pip install ...`
- `range`
- slicing
- tuple
- `type`
- whitespace indentation
- zero-indexing

:::
:::


<script defer>
    var registerRevealCallbacks = function() {
        Reveal.on('overviewshown', event => {
            document.querySelector(".line.right").hidden = true;
        });
        Reveal.on('overviewhidden', event => {
            document.querySelector(".line.right").hidden = false;
        });
    };
</script>